
Limited-Packet-Relay-Protocol
有限报文中继协议

简介：
有限报文中继协议是基于udp协议设计的二进制协议，使用“签名/验签”机制提供报文中继服务，不涉及“加密/解密”。
以下简称为协议。
签名/验签算法使用ed25519。
公钥私钥长度32字节，签名64字节（和x25519的密钥长度一致）。
工作量证明使用blake2b散列算法，计算前n位为0的散列值，散列长度32字节。
提供协议服务的主机不主动推送报文，租客必须通过发送心跳包或其他标准报文的方式通知主机发送报文。
主机可以通过“工作量证明”机制提供租约，更新租客白名单，或为不在租客白名单上的发件人提供中继服务。

名词：
主机-提供协议服务的服务器。
租客-通过完成工作量证明，将公钥放入主机租客列表，主机为租客提供报文中继服务。
访客-公钥不在主机租客列表中，但是仍然可以发送报文给租客。
发件人-报文的发送者，如果不在收件人白名单中，需要提交工作量证明才可以发送报文。
收件人-报文的接收者。

报文格式：
使用udp协议，长度 >=144 且 <= 508字节
签名64 + 时间戳8 + 发送者公钥32 + 接收者公钥32 + 指令8 + 载荷<=332
签名64 = ed25519(时间戳8 + 发送者公钥32 + 接收者公钥32 + 指令8 + 载荷<=332)
可用载荷508 - 64 - 8 - 32 - 32 - 8 = 364字节。
如果报文也加密，使用一次性32字节x25519公钥，则可用载荷364 - 32 = 332字节。
如果要复用公钥，则需要追加24字节随机数，可用载荷332 - 24 = 308 字节。
如果报文使用utf-8编码，则可以承载110/102个中文字符。
如果需要发送更长的消息，在上层应用解决，协议不承担此指责。

指令0x100 心跳 租客->主机 无前置指令：
签名64 + 时间戳8 + 租客公钥32 + 主机公钥32 + 指令8
长度 = 144

指令0x200 心跳 主机->租客 无前置指令：
签名64 + 时间戳8 + 主机公钥32 + 租客公钥32 + 指令8
长度 = 144

指令0x101 提交工作量证明 发件人->主机 前置指令0x602/0x604/0x608：
签名64 + 时间戳8 + 发件人公钥32 + 主机公钥32 + 指令8 + 载荷
载荷 = 前置指令0x602/0x604/0x608的签名 + S<=300
长度 <= 508
主机计算H = ed25519(前置指令0x602/0x604/0x608 + S)
H前n位应为0，具体多少位可以由服务器指定，无需公开，发送者可以从较少的位尝试，失败后增加位数直到成功。

指令0x401 拒绝工作量证明 主机->发件人 前置指令0x101：
签名64 + 时间戳8 + 主机公钥32 + 发件人公钥32 + 指令8 + 载荷
载荷 = 前置指令0x101的签名
长度 = 144 + 64 = 208

指令0x102 中继指令 发件人->主机 无前置指令：
签名64 + 时间戳8 + 发件人公钥32 + 收件人公钥32 + 指令8 + 载荷
载荷 = 任意数据<=364字节
长度 >= 144 & <= 508

指令0x402 拒绝中继指令 主机->发件人 前置指令0x102：
签名64 + 时间戳8 + 主机公钥32 + 发件人公钥32 + 指令8 + 载荷
载荷 = 前置指令0x102的签名
长度 = 144 + 64 = 208

指令0x202 接受中继指令 主机->发件人 前置指令0x102：
签名64 + 时间戳8 + 主机公钥32 + 发件人公钥32 + 指令8 + 载荷
载荷 = 前置指令0x102的签名
长度 = 144 + 64 = 208

指令0x602 要求工作量证明 主机->发件人 前置指令0x102：
签名64 + 时间戳8 + 主机公钥32 + 发件人公钥32 + 指令8 + 载荷
载荷 = 前置指令0x102的签名
长度 = 144 + 64 = 208

指令0x102 中继指令 主机->收件人 前置指令0x102：
签名64 + 时间戳8 + 发件人公钥32 + 收件人公钥32 + 指令8 + 载荷
载荷 = 任意数据<=364字节
长度 <= 508

指令0x802 中继成功 收件人->主机 前置指令0x102：
签名64 + 时间戳8 + 主机公钥32 + 收件人公钥32 + 指令8 + 载荷
载荷 = 前置指令0x102的签名
长度 = 144 + 64 = 208

指令0x104 申请租约 访客->主机 无前置指令：
签名64 + 时间戳8 + 访客公钥32 + 主机公钥32 + 指令8 + 载荷
载荷 = 任意数据>=64
长度 >= 144 + 64 = 208
注：原则上主机返回的报文长度不大于接受的报文长度，以预防放大攻击，所以要求一定的载荷。

指令0x204 接受租约 主机->访客 前置指令0x104：
签名64 + 时间戳8 + 主机公钥32 + 访客公钥32 + 指令8
载荷 = 前置指令0x104的签名
长度 = 144 + 64 = 208

指令0x404 拒绝租约 主机->访客 前置指令0x104：
签名64 + 时间戳8 + 主机公钥32 + 访客公钥32 + 指令8
载荷 = 前置指令0x104的签名
长度 = 144 + 64 = 208

指令0x604 要求工作量证明 主机->访客 前置指令0x104：
签名64 + 时间戳8 + 主机公钥32 + 访客公钥32 + 指令8
载荷 = 前置指令0x104的签名
长度 = 144 + 64 = 208

指令0x108 更新白名单 租客->主机 无前置指令：
签名64 + 时间戳8 + 租客公钥32 + 主机公钥32 + 指令8 + 载荷
载荷 = 白名单散列32 + 公钥签名n * 32， n >= 1 & <= 10
长度 >= 144 + 32 + 32 = 208 & <= 144 + 32 + 320 = 496
注1：如果n=1，要检查公钥是否全0，这是为了防止放大增加的无效公钥。
注2：如果公钥不在白名单内则加入白名单，否则移出白名单，白名单增序排列，依序散列。

指令0x208 散列匹配更新白名单成功 主机->租客 前置指令0x108：
签名64 + 时间戳8 + 主机公钥32 + 租客公钥32 + 指令8 + 载荷
载荷 = 前置指令0x108的签名
长度 = 144 + 64 = 208

指令0x408 散列不匹配更新白名单失败 主机->租客 前置指令0x108：
签名64 + 时间戳8 + 主机公钥32 + 租客公钥32 + 指令8 + 载荷
载荷 = 前置指令0x108的签名
长度 = 144 + 64 = 208

指令0x608 要求工作量证明 主机->租客 前置指令0x108：
签名64 + 时间戳8 + 主机公钥32 + 租客公钥32 + 指令8 + 载荷
载荷 = 前置指令0x108的签名
长度 = 144 + 64 = 208
注：主机更新白名单有一定工作量，如果频繁更新，就需要提交工作量证明。

指令0x808 重置白名单 租客->主机 无前置指令：
签名64 + 时间戳8 + 访客公钥32 + 主机公钥32 + 指令8 + 载荷
载荷 = 任意数据>=64
长度 >= 144 + 64 = 208
注：原则上主机返回的报文长度不大于接受的报文长度，以预防放大攻击，所以要求一定的载荷。

服务器逻辑

收到报文：
1、检查报文长度，如小于64 + 8 + 32 + 32 + 8 = 144字节，抛弃报文。
2、检查时间戳，与服务器时间差大于2^19（约8分44秒），抛弃报文。
3、校验签名，如失败，抛弃报文。
4、检查指令，确定报文类型。

指令0x100：
1、检查发件人是否是租客，如不是，抛弃报文。
2、记录租客地址与端口，记录时间戳，重置重试次数。

指令0x101：
1、检查发件人是否是租客，如是，记录租客地址与端口，记录时间戳，重置重试次数。
2、检查工作量前n位是否为0，如失败，抛弃报文。
3、根据签名查找前置报文0x602/0x604/0x608，如果没有找到，抛弃报文。
4、取出前置报文0x602/0x604/0x608，检查工作量，如失败，抛弃报文。
5、移除前置报文0x602/0x604/0x608。
6、检查前置报文0x602/0x604/0x608的时间戳，时间差大于2^n，抛弃报文。（n待定，暂定19，要在避免攻击和客户端压力间取得平衡）。
7、如果是报文0x602，取出并移除前置报文0x102，存入租客报文队列，返回报文0x202。
8、如果是报文0x604，将发件人公钥存入租客列表，记录租约时间戳，返回报文0x204。
9、如果是报文0x608，取出并移除前置报文0x108，尝试更新白名单，更新方式见指令0x108。

指令0x102：
1、检查发件人是否是租客，如是，记录租客地址与端口，记录时间戳，重置重试次数。
2、检查收件人公钥，如果不在租客列表内，返回报文0x402。
3、检查租客白名单，如发件人者在白名单内，接收报文0x102，存入租客报文队列，返回报文0x202。
4、如发件人者不在白名单内，储存报文0x102，要求发件人者提交工作量证明，生成报文0x602并储存，返回报文0x602。

指令0x802：
1、检查发件人是否是租客，如是，记录租客地址与端口，记录时间戳，重置重试次数。
2、检查租客报文发送队列，移除前置报文0x102。

指令0x104：
1、检查发送者是否是租客，如是，记录租客地址与端口，记录时间戳，重置重试次数。
2、检查报文长度，如<208，抛弃报文。
3、生成并储存报文0x604，返回报文0x604。

指令0x108：
1、检查发送者是否是租客，如是，记录租客地址与端口，记录时间戳，重置重试次数。
2、检查报文长度，如<208，抛弃报文。
3、检查租客白名单更新时间戳和当前时间戳的差值。
4、如果差值<=2^19，需要提交工作量证明，储存报文0x108，生成并储存报文0x608，返回报文0x608。
5、如果差值>2^19，尝试更新白名单。
6、生成白名单副本。
7、读取载荷内公钥，更新白名单副本，如果载荷内公钥在白名单内则移出，否则加入。
8、白名单增序排序，计算散列，和载荷内散列比较，如果不匹配，返回报文0x408。
9、如果散列匹配，更新白名单，更新白名单更新时间戳，移除白名单副本，返回报文0x208。

指令0x808
1、检查发送者是否是租客，如是，记录租客地址与端口，记录时间戳，重置重试次数。
2、检查报文长度，如<208，抛弃报文。
3、清空白名单，更新白名单更新时间戳，返回报文0x208。

空闲时 | 发送计时器触发时：
1、遍历租客。检查租约时间戳，对比当前时间与时间戳，如果差值大于常数c1，移除租客。
2、如果差值小于常数c1，如果租客已经激活，检查租客报文队列，如非空，检查时间戳。
3、对比当前时间与时间戳，如果差值小于常数c1x重试次数，继续等待。
4、如果差值大于常数c1x重试次数，检查重试次数，如大于c2，休眠租客（常数c1和c2待定）。
5、如果重试次数小于c2，记录时间戳，重置次数+1，发送报文0x102。

